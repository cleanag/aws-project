# -*- coding: utf-8 -*-
"""ingredient.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jkQgwqehmK_rAc8GtnMoiV2ItqvbqX-S
"""

import json
import boto3
import re

bedrock = boto3.client("bedrock-runtime", region_name="us-east-1")

STRICT_JSON_INSTRUCTION = (
    "아래 형식의 **순수 JSON**만 출력하세요. 설명 문장이나 코드블록 금지.\n"
    '{\n'
    '  "title": "음식 이름",\n'
    '  "explain": "음식에 대한 한두 문장 설명",\n'
    '  "ingredients": ["입력 재료 중 사용한 것들만"],\n'
    '  "recipe": "1. ~\\n2. ~\\n3. ~ 형태의 5단계 이하 조리법"\n'
    '}\n'
    "키 이름과 자료형을 반드시 지키세요."
)

def _safe_parse_json(text: str) -> dict:
    """Claude가 앞뒤에 텍스트를 붙였을 때 대비한 안전 파서."""
    try:
        return json.loads(text)
    except Exception:
        m = re.search(r'\{.*\}', text, re.S)
        if m:
            return json.loads(m.group(0))
        raise ValueError("Model did not return valid JSON.")

def lambda_handler(event, context):
    headers = {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    }

    # Preflight
    if event.get("httpMethod") == "OPTIONS":
        return {"statusCode": 204, "headers": headers, "body": ""}

    try:
        body = json.loads(event.get("body") or "{}")
        ingredients = body.get("ingredients", [])  # 프론트에서 보낸 재료 배열

        if not isinstance(ingredients, list) or not ingredients:
            return {
                "statusCode": 400,
                "headers": headers,
                "body": json.dumps({"error": "ingredients가 필요합니다. 예: [\"양파\",\"계란\"]"}),
            }

        # 프롬프트: 음식 이름, 설명, 재료(입력 목록의 부분집합), 방법을 JSON으로만 반환하도록 강제
        user_prompt = (
            f"재료 목록: {', '.join(map(str, ingredients))}\n"
            "위 재료 중 가능한 것만 사용해 만들 수 있는 한 가지 요리를 제안하세요.\n"
            "요구사항:\n"
            "1) title: 요리 이름\n"
            "2) explain: 한두 문장 설명\n"
            "3) ingredients: 입력 재료 목록의 부분집합만 사용\n"
            "4) recipe: 1~5단계로, 한 줄에 한 단계씩 '1. '부터 번호 매기기\n\n"
            + STRICT_JSON_INSTRUCTION
        )

        resp = bedrock.invoke_model(
            modelId="anthropic.claude-3-sonnet-20240229-v1:0",
            contentType="application/json",
            accept="application/json",
            body=json.dumps({
                "anthropic_version": "bedrock-2023-05-31",
                "messages": [{"role": "user", "content": user_prompt}],
                "max_tokens": 800,
                "temperature": 0.5
            })
        )

        raw = json.loads(resp["body"].read())
        text = raw["content"][0]["text"]  # Claude 텍스트
        parsed = _safe_parse_json(text)

        # 필수 키 검증 및 타입 보정
        title = str(parsed.get("title", "")).strip()
        explain = str(parsed.get("explain", "")).strip()
        ing = parsed.get("ingredients", [])
        recipe = str(parsed.get("recipe", "")).strip()

        if not title or not explain or not recipe or not isinstance(ing, list):
            raise ValueError("Missing required fields in model output.")

        # ingredients는 입력값의 부분집합만 허용
        ing_set = set(map(str, ingredients))
        cleaned_ingredients = [x for x in ing if str(x) in ing_set]

        return {
            "statusCode": 200,
            "headers": headers,
            "body": json.dumps({
                "title": title,
                "explain": explain,
                "ingredients": cleaned_ingredients,  # [] of String (코틀린에서 ArrayList<String>로 매핑)
                "recipe": recipe                    # String
            })
        }

    except Exception as e:
        return {
            "statusCode": 500,
            "headers": headers,
            "body": json.dumps({"error": str(e)})
        }

