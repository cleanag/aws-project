# -*- coding: utf-8 -*-
"""price.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iZSze3E-TdjbViyMn9e4UizQQTIP5iKX
"""

import json
import boto3
import csv
import io
import random
import re
from typing import List, Tuple, Dict, Any  # 런타임 호환용

bedrock = boto3.client("bedrock-runtime", region_name="us-east-1")
s3 = boto3.client("s3")

S3_BUCKET = "smct-ht-11-solo-cook"
S3_KEY    = "Final_Prices.csv"

STRICT_JSON_INSTRUCTION = (
    "아래 형식의 순수 JSON만 출력하세요. 설명 문장이나 코드블록 금지.\n"
    "{\n"
    '  "title": "음식 이름",\n'
    '  "explain": "음식에 대한 한두 문장 설명",\n'
    '  "ingredients": ["입력 재료 중 사용한 것들만"],\n'
    '  "recipe": "1. ~\\n2. ~\\n3. ~ 형태의 5단계 이하 조리법"\n'
    "}\n키 이름과 자료형을 반드시 지키세요."
)

def _safe_parse_json(text: str) -> dict:
    try:
        return json.loads(text)
    except Exception:
        m = re.search(r"\{.*\}", text, re.S)
        if m:
            return json.loads(m.group(0))
        raise ValueError("Model did not return valid JSON.")

def _load_csv(bucket: str, key: str) -> List[Tuple[str, float]]:
    obj = s3.get_object(Bucket=bucket, Key=key)
    text = obj["Body"].read().decode("utf-8-sig", errors="ignore")
    reader = csv.reader(io.StringIO(text))
    rows = list(reader)[1:]  # 헤더 제외
    out: List[Tuple[str, float]] = []
    for r in rows:
        if len(r) < 2:
            continue
        name = r[0].strip()
        try:
            price = float(str(r[1]).strip())
        except ValueError:
            continue
        out.append((name, price))
    return out

def lambda_handler(event, context):
    headers = {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    }

    # CORS preflight
    if isinstance(event, dict) and event.get("httpMethod") == "OPTIONS":
        return {"statusCode": 204, "headers": headers, "body": ""}

    try:
        # -------- 견고한 budget 파싱 시작 --------
        budget = None
        raw_body = event.get("body") if isinstance(event, dict) else event  # 비정상 입력 보호

        # 1) body가 숫자면 그대로
        if isinstance(raw_body, (int, float)):
            budget = raw_body

        # 2) body가 문자열이면 JSON 파싱 시도
        elif isinstance(raw_body, str):
            try:
                parsed = json.loads(raw_body)
            except Exception:
                # "10000" 같은 숫자 문자열일 수 있음
                try:
                    budget = float(raw_body)
                except Exception:
                    parsed = None
            if budget is None and isinstance(parsed, dict):
                budget = parsed.get("budget")
            if budget is None and isinstance(parsed, (int, float)):
                budget = parsed

        # 3) body가 dict면 바로 꺼냄
        elif isinstance(raw_body, dict):
            budget = raw_body.get("budget")

        # 4) 쿼리스트링 허용 (?budget=10000)
        if budget is None and isinstance(event, dict):
            qs = (event.get("queryStringParameters") or {}).get("budget")
            if qs is not None:
                try:
                    budget = float(qs)
                except Exception:
                    pass

        if not isinstance(budget, (int, float)):
            return {
                "statusCode": 400,
                "headers": headers,
                "body": json.dumps({"error": 'budget(숫자)가 필요합니다. 예: {"budget": 10000} 또는 body=10000'}, ensure_ascii=False),
            }
        # -------- 견고한 budget 파싱 끝 --------

        # CSV에서 무작위 4개 추출
        items = _load_csv(S3_BUCKET, S3_KEY)
        if not items:
            raise ValueError("CSV 파일이 비어있습니다.")
        selected = random.sample(items, min(4, len(items)))
        candidate_names = [name for name, _ in selected]
        name_to_price = {name: price for name, price in selected}

        # 프롬프트
        user_prompt = (
            f"현재 예산: {budget}원\n"
            f"재료 후보: {', '.join(candidate_names)}\n"
            "위 재료 중 가능한 것만 사용해 만들 수 있는 한 가지 요리를 제안하세요.\n"
            "요구사항:\n"
            "1) title: 요리 이름 (소문자)\n"
            "2) explain: 한두 문장 설명\n"
            "3) ingredients: 위 재료 목록 중 일부만 사용 (문자열 배열)\n"
            "4) recipe: 1~5단계, 각 단계는 한 줄씩 작성\n\n"
            + STRICT_JSON_INSTRUCTION
        )

        payload = {
            "anthropic_version": "bedrock-2023-05-31",
            "messages": [{
                "role": "user",
                "content": [
                    {"type": "text", "text": user_prompt}
                ]
            }],
            "max_tokens": 800,
            "temperature": 0.5
        }

        resp = bedrock.invoke_model(
            modelId="anthropic.claude-3-sonnet-20240229-v1:0",
            contentType="application/json",
            accept="application/json",
            body=json.dumps(payload)
        )

        raw = json.loads(resp["body"].read())
        if not isinstance(raw, dict) or not raw.get("content"):
            raise ValueError(f"Bedrock empty content: {raw}")
        text = raw["content"][0]["text"]
        parsed = _safe_parse_json(text)

        title   = str(parsed.get("title", "")).strip()
        explain = str(parsed.get("explain", "")).strip()
        ing_ai  = parsed.get("ingredients", [])
        recipe  = str(parsed.get("recipe", "")).strip()

        if not title or not explain or not recipe or not isinstance(ing_ai, list):
            raise ValueError("Missing required fields in model output.")

        # 후보 집합에 존재하는 재료만 유지 + 순서 유지
        candidate_set = set(candidate_names)
        cleaned_ingredients: List[str] = [str(x) for x in ing_ai if str(x) in candidate_set]

        # 가격 리스트(int). 순서 = cleaned_ingredients
        ingredients_price: List[int] = [int(round(name_to_price.get(n, 0))) for n in cleaned_ingredients]

        return {
            "statusCode": 200,
            "headers": headers,
            "body": json.dumps({
                "title": title,                          # string
                "explain": explain,                      # string
                "ingredients": cleaned_ingredients,      # ArrayList<String>
                "ingredients_price": ingredients_price,  # ArrayList<Int>
                "recipe": recipe                         # string
            }, ensure_ascii=False)
        }

    except Exception as e:
        print(f"[ERROR] {type(e).__name__}: {e}")
        return {
            "statusCode": 500,
            "headers": headers,
            "body": json.dumps({"error": str(e)}, ensure_ascii=False)
        }